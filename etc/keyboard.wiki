[[/index|Main]]

= Keyboard =

Что же, начнем. Сначала разберемся, как можно настроить смену раскладки клавиатуры.


    Посмотрим, как то же самое можно сделать руками, и чего еще можно добиться.
    Давайте поставим переключение на правый Alt (он же AltGr):

    $ setxkbmap -layout us,ru -option grp:toggle


    Но где можно узнать, какие еще есть варианты, и как создать свои? Все файлы лежат /usr/share/X11/xkb/symbols/. И наши переключения находятся в /usr/share/X11/xkb/symbols/group. Вот так выглядит выбранный вариант:

    partial modifier_keys
    xkb_symbols "toggle" {
    virtual_modifiers AltGr;
    key <RALT> {
        symbols[Group1] = [ ISO_Next_Group ],
        virtualMods = AltGr
    };
    };


    Там же можно найти множество других вариантов, в том числе ациклические, которые позволяют быть уверенным, какой язык будет после переключения, вместо того, чтобы каждый раз проверять раскладку или смотреть на индикатор.


Ациклическое переключение раскладок

Изменим циклическое переключение по AltGr на ациклическое: AltGr переключает на латинскую раскладку, Shift+AltGr — на русскую.

Перед тем как что-то менять, посмотрим на текущие настройки:

$ setxkbmap -layout us,ru -print


Должны получить что-такое (pc105 может отличаться в зависимости от количества клавиш на вашей клавиатуре):

xkb_keymap {
    xkb_keycodes  { include "evdev+aliases(qwerty)" };
    xkb_types     { include "complete"  };
    xkb_compat    { include "complete"  };
    xkb_symbols   { include "pc+us+ru:2+inet(evdev)"  };
    xkb_geometry  { include "pc(pc105)" };
};


Теперь запишем это в конфигурационный файл ~/.config/xkb/config.

В файле /usr/share/X11/xkb/symbols/group можно найти аналогичный вариант с CapsLock, откуда можно понять, что на us будет переключать ISO_First_Group, а на ru — ISO_Second_Group.

Вот такая строчка

key <CAPS> { [ ISO_First_Group, ISO_Last_Group ] }; 


говорит, что клавиша <CAPS> при обычном нажатии вызывает ISO_First_Group, а вместе с Shift — ISO_Last_Group.

Изменим в только что созданном файле xkb_symbols:

xkb_keymap {
    xkb_keycodes  { include "evdev+aliases(qwerty)" };
    xkb_types     { include "complete"  };
    xkb_compat    { include "complete"  };
    xkb_geometry  { include "pc(pc105)" };

    xkb_symbols "my"  { 
    include "pc+us+ru:2+inet(evdev)"  

    key <RALT> { [ ISO_First_Group, ISO_Last_Group ] }; 
    };
};


Проверим, что у нас получилось. Загружаем конфиг:

$ xkbcomp $HOME/.config/xkb/config $DISPLAY


Теперь язык должен переключаться по заданным комбинациям.

Замечание

Это очень удобно, когда набираешь текст, используя сразу две раскладки (например, TeX), потому что, переключение происходит часто и гораздо проще каждый раз когда начинаешь писать русский текст нажимать нужные клавиши, чем проверять, какой язык стоит сейчас, и переключать, если нужно. Просто меньше тратишь умственных сил, меньше совершаешь ошибок.

Еще один плюс ациклического переключения — можно больше не использовать никаких индикаторов.

Изменение клавиш

Двоеточие и точка с запятой

Поменяем местами двоеточие и точку с запятой. Как задать значение мы уже знаем, осталось понять как называются символы. Это можно посмотреть в тех же файлах /usr/share/X11/xkb/symbols/. Выберем файл us и найдем нужную клавишу:

key <AC10> { [ semicolon, colon ] };      


Осталось записать в наш конфигурационный файл в обратном порядке.

ESC и CapsLock

Поменяем ESC и CapsLock. В той же директории в файле capslock можно найти:

hidden partial modifier_keys
xkb_symbols "swapescape" {
    key <CAPS> { [ Escape ] };
    key <ESC>  { [ Caps_Lock ] };
};
hidden partial modifier_keys
xkb_symbols "escape" {
    key <CAPS> { [ Escape ] };
};


partical — специальные куски, которые мы можем включать в другие раскладки.
Теперь либо пишем include "swapescape", либо просто копируем код.

Alt и Win

Еще аналогично можно поменять, например, левый Alt и Win, что особенно удобно в i3wm, если поставить главный модификатор на Win, то он будет ближе к остальной клавиатуре, и плюс мы не ограничим себя в использовании Alt в комбинациях различный программ (браузер, файловый менеджер...).

Модификаторы

Для чего вообще они нужны? Можно задать комбинации, которые будут позволять нам быстрее и удобнее набирать какие-то символы или вызывать какое-то действие, помещая поверх других, то есть эти комбинации не будут пересекаться с уже созданными или с комбинациями заданными системой.

Существует два дополнительных уровня: level3, level5. И еще комбинации с Shift.

Сделаем так, чтобы клавиша CapsLock в комбинации с h, j, k, l давала эффект стрелки. Тогда не нужно будет каждый раз тянуться ним.

Назначим модификатор (мы уже решили поставить туда ESC, но можно сделать и то и другое: об этом далее):

key <CAPS> { [ ISO_Level3_Shift ] };


Если мы хотим назначить для разных раскладок разное значение, то сначала нужно их определить:

name[group1] = "English (US)";
name[group2] = "Russian";


далее

key <CAPS> {
    symbols[group1] = [ ISO_Level3_Shift ],
    symbols[group2] = [ Caps_Lock ]
}


Теперь нужно настроить клавиши h, j, k, l. Сначала узнаем их имя — тоже можно посмотреть файл раскладки, это несложно. Их зовут <AC06>,… <AC09>. Какие команды вызывают стрелки можно узнать совершенно аналогично. Дальше пропишем поведение в комбинации с модификатором:

key <AC06> { [ h, H, KP_Left  ] };
key <AC07> { [ j, J, KP_Down  ] };
key <AC08> { [ k, K, KP_Up    ] };
key <AC09> { [ l, L, KP_Right ] };


При нормальном нажатии будет обычная буква, при нажатии с шифтом — заглавная, с модификатором третьего уровня — стрелки.

Назначение модификатора как второе значение клавиши

Кроме стрелок можно назначить на третий слой символы или другие операции.
Давайте сделаем, чтобы кроме функции модификатора клавиша CapsLock выполняла и предназначенную ей миссию ранее — была ESC.

Для этого нам понадобится xcape, которая позволяет назначить на на клавишу значение, которое она будет иметь, если нажать ее не в комбинации. Еще есть полезная функция: можно настроить время, после истечения которого ее эффект отменяется.

Как я уже обещал, мы сделаем так, чтобы при однократном нажатии клавиши CapsLock вызывался ESC, а в комбинациях выступала в роли модификатора третьего уровня.

Для этого нужно выполнить

$ xcape -t <время в миллисекундах> -e "первое значение=втрое значение"


Я использую интервал 500 миллисекунд. Для нашей цели:

$ xcape -t 500 -e "ISO_Level3_Shift=Escape"


Дальнейшие изменения

Когда я пишу в TeX, я использую достаточно много одинаковых символов, но в разных раскладках. Поэтому появилась идея сделать их максимально похожими. В раскладках по умолчанию сильно отличаются положения точки, запятой, кавычек, квадратных и фигурных скобок, вопросительных знаков, различных слэшей...

Здесь было две идеи:

    Поставим редко используемые русские буквы на крайних правых клавишах на третий слой других букв.
    Схема была такая:

    Клавиша 	Третий слой
    у 	ю
    в 	б
    ь 	ъ
    з 	ж
    щ 	х

    Для достижения такого эффекта добавляем в конфиг (здесь для у/ю, для остальных аналогично, названия букв русского алфавита можно посмотреть, где и все остальное):

    key <AD03> {                                            
    type = "ALPHABETIC",
    type[group2] = "FOUR_LEVEL",
    symbols[group2] = [Cyrillic_u, Cyrillic_U, Cyrillic_yu, Cyrillic_YU]
    };


    А на освобожденные клавиши просто назначаем такие же символы, как во второй раскладке.
    Этот вариант оказался для меня неудобным и скорее снизил скорость, так как приходилось вспоминать и искать нужные буквы (хоть я выбирал специально созвучные), кроме этого я понял, что не так уж и редко они используются. А заглавные вообще тяжело набирать было.

    Этот вариант я использую и сейчас: давайте оставим русские буквы на своих местах, а на третий слой на них назначим те символы, которые стоят на них на английской раскладке.
    Тогда мы сможем нажимать одинаковые клавиши, но с модификатором (причем, если мы не назначим что-то другое поверх символов а английской раскладке, то ничего не случиться, если мы будем нажимать модификатор и в ней тоже).
    Получаем такую схему:

    key <AD11> {
    type[group2]="FOUR_LEVEL",
    symbols[group2]=[Cyrillic_ha, Cyrillic_HA, bracketleft, braceleft]
    };
    key <AD12> {
    type[group2]="FOUR_LEVEL",
    symbols[group2]=[Cyrillic_hardsign, Cyrillic_HARDSIGN, bracketright, braceright]
    };
    key <AC10> {
    type[group2]="FOUR_LEVEL",
    symbols[group2]=[Cyrillic_zhe, Cyrillic_ZHE, colon, semicolon]
    };
    key <AC11> {
    type[group2]="FOUR_LEVEL",
    symbols[group2]=[Cyrillic_e, Cyrillic_E, apostrophe, quotedbl]
    };
    key <AB08> {
    type[group2]="FOUR_LEVEL",
    symbols[group2]=[Cyrillic_be, Cyrillic_BE, comma, less]
    };
    key <AB09> {
    type[group2]="FOUR_LEVEL",
    symbols[group2]=[Cyrillic_yu, Cyrillic_YU, period, greater]
    };


    Еще можем поставить в русской раскладке слэш и вопросительный знак туда, где они стоят в английской.

    key <AB10> {
    symbols[group2]=[slash, question]
    };


    Плюс к этому добавляется возможность сделать одинаковыми и символы на цифрах, так как и кавычки, и двоеточие, и точка с запятой будет на других клавишах.

    key <AE03> { [ 3, numbersign, number, apostrophe ] };
    key <AE04> { [ 4, dollar ] };
    key <AE06> { [ 6, asciicircum ] };
    key <AE07> { [ 7, ampersand ] };


    И главное, что это реально упростило процесс набора текста.


Замечание

Аналогично можно добавлять пятый слой, хотя пока лично я не испытываю никакой нужды — вполне хватает третьего.

Интересный вариант BackSpace напоследок

А может хватит тянуться далеко-далеко в дальний угол клавиатуры?
Поставим-ка BackSpace на $mod3+Space ($mod3 наш модификатор третьего уровня)!

key <SPCE> { [ space, space, BackSpace, BackSpace ] };


P.S.

Все настройки в принципе применимы для любых Linux дистрибутивов, использующих X.

Полные конфиги можно найти на GitHub.

Этот пост стал для меня отправной точкой к пониманию того, как можно и нужно настроить клавиатуру.
