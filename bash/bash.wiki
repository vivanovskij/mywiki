[[../index|Main]]

== Содержание ==

* [[bash_notes|notes]]
* [[bash_hotkeys|hotkeys]]
* [[bash_history|history]]
* [[bash_tabs|tabs]]
* [[bash_rename_files|rename files]]
* [[bash_group_symbols|Групповые символы]]
* Commands:
    * [[commands/bash_ls|ls]]
    * [[commands/bash_cp|cp]]
    * [[commands/bash_mv|mv]]
    * [[commands/bash_file|file]]
    * [[commands/bash_rsync|rsync]]
    * [[commands/bash_ssh|ssh]]
    * [[commands/bash_mkdir|mkdir]]
    * [[commands/bash_rm|rm]]
    * [[commands/bash_ln|ln]]
    * [[commands/bash_man|man]]
    * [[commands/bash_whatis|whatis]]
    * [[commands/bash_info|info]]

    Перенаправление ввода/вывода
    ----------------------------

cat     объединяет файлы
sort    сортирует строки текста 
uniq    сообщает о повторяющихся строках 
wc      выводит число строк, слов и байт 
grep    находит и выводит строки, соотв. шаблону 
head    выводит первые строки из файла 
tail    выводит последние строки из файла 
tee     читает данные со stdin и записывает
        в stdout и в файлы
>       оператор перенаправления (перезаписывает файл)
>>      то же, но дописывает файл

ls -l /usr/bin > ls-output.txt

    Перенаправление stderr
    -----------------------

Чтобы перенаправить stderr, нужно указать его дескриптор файла.
0 - stdin
1 - stdout
2 - stderr
Командная оболочка поддерживает синтаксис перенаправления файлов с использованием номеров файловых дескрипторов. Так как stderr соотв. файловый дескриптор 2, мы можем перенаправить его так:
ls -l /bin/usr 2> ls-error.txt

    Перенаправление stdout и stderr в один файл
    -------------------------------------------

1. ls -l /bin/usr > ls-output.txt 2>&1

Здесь выполняется два перенаправления. Сначала - перенаправление stdout в файл ls-output.txt, а затем, с использованием нотации 2>&1, - перенаправление файлового дескриптора 2 (stderr) в файловый дескриптор 1 (stdout)

2. ls -l /bin/usr &> ls-output.txt

В данном примере используется единственный оператор &>, перенаправляющий stdout и stderr в файл ls-output.txt

    Удаление нежелательного вывода
    ------------------------------

Иногда вывод команды нужно отбросить. Система даёт такую возможность, предоставляя специальный файл /dev/null, куда можно перенаправить вывод. Этот файл представляет системное устройство, называемое битоприёмником (bit bucket), или мусорной корзиной, которое принимает любой ввод и ничего с ним не делает.

ls -l /bin/usr 2> /dev/null

cat [file ...]
В отсутствие аргументов cat копирует содержимое стандартного ввода в стандартный вывод. Эту её особенность можно использовать для создания коротких текстовых файлов.

cat > eat_more.txt
"Съешь ещё этих мягких французских булок, да выпей чаю." <C-d> (чтобы сообщить команде cat, что достигнут конец файла на стандартном вводе)

        Конвейеры
        ---------

"Умение" команд читать данные со стандартного ввода и выводить результаты в стандартный вывод используется механизмом командной оболочки, который называется конвейером. С помощью оператора конвейера | (вертикальная черта) стандартный вывод одной команды можно связать со стандартным вводом другой.

команда1 | команда2

ls -l /usr/bin | less


        Фильтры
        -------

Конвейеры часто используются для выполнения сложных операций с данными. Они позволяют объединить вместе несколько команд. Часто команды, используемые таким способом, называют фильтрами. Фильтры принимают ввод, изменяют его определённым образом и выводят результат.

1. Фильтр sort сортирует вывод по алфавиту
ls /bin /usr/bin | sort | less

2. Фильтр uniq - поиск и удаление повторяющихся строк
ls /bin /usr/bin | sort | uniq | less

3. Фильтр wc - (word count) используется для подсчета числа строк, слов и байтов в файлах.
wc ls-output.txt
ls /bin /usr/bin | sort | uniq | wc -l 
(ключ -l выводит только число строк)

4. grep поиск строк, соответствующих шаблону.
Часто используется для поиска в файлах текста по шаблону:
grep шаблон [файл ...]
ls /bin /usr/bin | sort | uniq | grep zip
Параметры:
-i игнор регистра при поиске
-v выводить строки, где совпадение не найдено

5. head/tail выводят первые/последние 10 строк файла
С помощью ключа -n можно изменить кол-во выводимых строк
head -n 5 ls-output.txt
ls /usr/bin | tail -n 5
tail -f /var/log/messages
ключ -f позволяет следить за файлом и при добавлении в конец этого файла новых строк немедленно выводит их до тех пор пока не нажать <C-C>

6. tee читает данные со stdin и копирует их в stdout (чтобы дать возможность передать их дальше по конвейеру) и в один или несколько файлов. Это может пригодиться для сохранения промежуточных результатов обработки в конвейере.
ls /usr/bin | tee ls.txt | grep zip



        Команда echo
        ------------

echo выводит свои текстовые аргументы в stdout
echo this is a test
echo *
echo ~
echo $((2 + 2))

echo $((выражение))
Механизм подстановки арифметических выражений позволяет использовать только целые числа (невещественные), зато поддерживает множество арифметических операций.

Операторы:

+   Сложение
-   Вычитание
*   Умножение
/   Деление (результат будет целое число из-за того, что
    подстановка поддерживает только целочисленную арифм.)
%   Деление по модулю или остаток от деления
**  Возведение в степень  

echo $(($((5**2)) * 3))

Для группировки подвыражений допускается использование одиночных круглых скобок.

echo $(((5**2) * 3))

    Подстановка фигурных скобок
    ---------------------------

$ echo Впереди-{A,B,C}-позади
Впереди-А-позади Впереди-В-позади Впереди-С-позади

$ echo Число {1..5}

$ echo {Z..A}

$ echo a{A{1,2},B{3,4}}b

Пример создания группы каталогов с именами, состоящими из номера года и месяца в хронологическом порядке:
$ mkdir Pictures
$ cd Pictures
$ mkdir {2009..2011}-0{1..9} {2009..2011}-{10..12}
$ mkdir -p {2009..2011}/{01..12}    ключ -p нужен для создания родительского
                                    каталога


    Подстановка параметров
    ----------------------

echo $USER

Чтобы увидеть список доступных переменных:
printenv | less


    Подстановка команд
    ------------------

Подстановка команд позволяет использовать поток вывода команд в качестве аргументов других команд:
echo $(ls)

ls -l $(which cp)   Здесь результат команды which cp передается как аргумент команде ls, благодаря чему мы получаем информацию о программе cp, не зная полного пути к ней.

Можно использовать конвееры:
file $(ls /usr/bin/* | grep zip)

Альтернативный синтаксис, унаследованный от более старых командных оболочек. Вместо знака доллара и круглых скобок используются обратные апострофы:

ls -l `which cp`


    Экранирование
    -------------

1. Двойные кавычки
Если заключить текст в двойные кавычки, все спецсимволы потеряют своё значение и будут интерпретироваться как обычные симовлы. Исключение сост.: $, \ и `. То есть разбиение на слова, подстановка путей, подстановка тильды и подстановка фигурных скобок выполняться не будут, но подстановка параметров, подстановка значений арифметических выражений и подстановка команд всё ещё будут выполняться.

2. Одиночные кавычки
Подавляют все подстановки

3. Экранирование символов
Обратный слеш \ используется для экранирования одного симовла.
Чтобы включить сам экранирующий символ, его также нужно экранировать \\.

    Управляющие последовательности

\a      Подать звуковой сигнал
\b      Забой (bakspace)
\n      Новая строка
\r      Возврат каретки
\t      Табуляция

Параметр -e команды echo включает интерпретацию управляющих последовательностей. Их можно также заключать в конструкцию $' '.

Пример использования команды sleep:
    sleep 10; echo -e "Time's up\a"

То же самое можно выразить так:
    sleep 10; echo "Time's up" $'\a'
