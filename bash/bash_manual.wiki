[[/index|Main]]

[[bash_notes|notes]]
[[bash_hotkeys|hotkeys]]

= Contents =
* [[#History|История]]
* [[#Tabs|Tabs]]
* [[#Rename files|Rename files]]
* [[#Group symbols|Групповые символы]]
* [[#Input/Output|Перенаправление ввода-вывода]]
* [[#Stderr|Перенаправление stderr]]
* [[#Conveers|Конвееры]]
* [[#RegEx|Регулярные выражения]]
* [[#filters|Фильтры]]:
    * [[#sort|sort]]
    * [[#uniq|uniq]]
    * [[#wc|wc]]
    * [[#grep|grep]]
    * [[#head/tail|head/tail]]
    * [[#tee|tee]]
* [[#Commands|Commands]]:
    * [[#ls|ls]]
    * [[#cp|cp]]
    * [[#mv|mv]]
    * [[#file|file]]
    * [[#rsync|rsync]]
    * [[#ssh|ssh]]
    * [[#mkdir|mkdir]]
    * [[#rm|rm]]
    * [[#ln|ln]]
    * [[#man|man]]
    * [[#whatis|whatis]]
    * [[#info|info]]
    * [[#cat|cat]]
    * [[#echo|echo]]


== History ==
$ history | less
$ history | grep {text}

!{num}      подставить {num} запись
!!          повторяет последнюю команду
!{str}      повторяет последнюю команду, начинающ. с указ. строки
!?{str}     повторяет последнюю команду, содержащ. указ. строку
C-R         поступательный поиск <Enter> - выполнить команду
            C-J скопировать запись в командную строку
            C-R (ещё раз) - переместиться по списку истории вверх
            C-G или С-С - завершить поиск
C-P         переход к предыдущей записи в истории
C-N         переход к следующей записи в истории
A-<         переход в начало списка истории
A->         переход в конец списка истории
A-P         поиск в обратном порядке
A-N         поиск в прямом порядке
C-O         выполнить тeкущую команду в списке истории и перейти к след.


== Tabs ==
C-S-T           открыть новую вкладку
A-{num}         открыть num вкладку
C-D             закрыть вкладку

S-PgUp/PgDown   скролл


== Rename files ==
[[vifm|Переименование с помощью vifm]]

Можно использовать утилиту rename дистрибутива ArchLinux'a (см. man rename).
Но в нём не работают регулярные выражения.

Чтобы исп. регулярные выражения нужно установить утилиту perl-rename:
sudo pacman -S perl-rename

Для удобного запуска perl-rename в терминале можно установить alias в .bashrc:
alias prename='perl-rename'

В терминале запускаем с помощью команды prename

Синтаксис:
rename [ -v ] [ -n ] [ -f ] perlexpr [ files ]

-v, --verbose
Verbose: print names of files successfully renamed.
-n, --no-act
No Action: show what files would have been renamed.
-f, --force
Force: overwrite existing files.

For example, to rename all files matching "*.bak" to strip the extension, you might say
        rename 's/\.bak$//' *.bak
To translate uppercase names to lower, you'd use
        rename 'y/A-Z/a-z/' *
Заменить все пробелы нижним подчёркиванием:
        rename 's/\s/_/g


Для группового переименования файлов (напр. *.jpg)
perl-rename '$N=sprintf("%04d",++$N); s/.*/$N.jpg/' *.jpg


=== RegEx ===
Регулярные выражения:

\d - соответствует цифре,
\D - соответствует любому символу, кроме цифры,
\s - соответствует любому из "пробельных символов" (пробел, вертикальная , или горизонтальная табуляция, символ новой строки и т. д.),
\S - любой символ, кроме "пробельного",
\w - алфавитно-цифровой символ (любая буква, цифра или символ подчеркивания),
\W - любой символ, кроме букв, цифр и символа подчеркивания,

^ - начало строки текста,
$ - конец строки или позиция перед символом начала новой строки, распо-ложенного в конце,

$' - подстрока, следующая за совпадением.
$& - совпадение с шаблоном поиска
$` - подстрока, расположенная перед совпадением
$^R - результат вычисления утверждения в теле шаблона
$n - n-ный фрагмент совпадения
\n - n-ный фрагмент совпадения вызываемый в самом шаблоне
$+ - фрагмент совпадения
$* - разрешает выполнять поиск в многострочных файлах
@- - спецмассив, который содержит начальную позицию найденного слова
@+ - массив, содержащий позицю последнего найденного слова

* - ноль или несколько совпадений,
+ - одно или несколько совпадений,
? - ноль совпадений или одно совпадение,
{n} - ровно n совпадений,
{n,} - по крайней мере n совпадений,
{n,m} - от n до m совпадений.

/i игнорировать регистр
/x игнорировать пропуски в шаблоне и разрешить комментарии.
/g модификатор разрешающий выполнение поиска/замены везде, где это возможно
/gc не сбрасывается позиция при неудачном поиске.
/s разрешается совпрадение . с \n, игнорируется $*.
/m разрешить совпадение ^ и $ для начала и конца строки во внутренних переводах строк
/o однократная компиляция
/e правая часть s/// представляет собой выполняемый код
/ee правая часть s/// выполняется, после чего возвращаемое значение интерпретируется снова.
=========================================================



== Group symbols ==

*           Любая последовательность любых символов
?           Любой один символ
[символы]   Любой один символ из указанного множества символов
[!символы]  Любой один символ, не принадлежащий указанному множеству символов
[:класс:] Любой один символ, принадлежащий указанному классу


[:alnum:]   Любой алфавитно-цифровой символ
[:alpha:]   Любой алфавитный символ
[:digit:]   Любой цифровой символ
[:lower:]   Любая буква в нижнем регистре
[:upper:]   Любая буква в верхнем регистре


== Input/Output ==

cat     объединяет файлы
sort    сортирует строки текста 
uniq    сообщает о повторяющихся строках 
wc      выводит число строк, слов и байт 
grep    находит и выводит строки, соотв. шаблону 
head    выводит первые строки из файла 
tail    выводит последние строки из файла 
tee     читает данные со stdin и записывает
        в stdout и в файлы
>       оператор перенаправления (перезаписывает файл)
>>      то же, но дописывает файл

ls -l /usr/bin > ls-output.txt


== Stderr ==

Чтобы перенаправить stderr, нужно указать его дескриптор файла.
0 - stdin
1 - stdout
2 - stderr
Командная оболочка поддерживает синтаксис перенаправления файлов с использованием номеров файловых дескрипторов. Так как stderr соотв. файловый дескриптор 2, мы можем перенаправить его так:
ls -l /bin/usr 2> ls-error.txt

    Перенаправление stdout и stderr в один файл
    -------------------------------------------

1. ls -l /bin/usr > ls-output.txt 2>&1

Здесь выполняется два перенаправления. Сначала - перенаправление stdout в файл ls-output.txt, а затем, с использованием нотации 2>&1, - перенаправление файлового дескриптора 2 (stderr) в файловый дескриптор 1 (stdout)

2. ls -l /bin/usr &> ls-output.txt

В данном примере используется единственный оператор &>, перенаправляющий stdout и stderr в файл ls-output.txt

    Удаление нежелательного вывода
    ------------------------------

Иногда вывод команды нужно отбросить. Система даёт такую возможность, предоставляя специальный файл /dev/null, куда можно перенаправить вывод. Этот файл представляет системное устройство, называемое битоприёмником (bit bucket), или мусорной корзиной, которое принимает любой ввод и ничего с ним не делает.

ls -l /bin/usr 2> /dev/null


== Conveers ==

"Умение" команд читать данные со стандартного ввода и выводить результаты в стандартный вывод используется механизмом командной оболочки, который называется конвейером. С помощью оператора конвейера | (вертикальная черта) стандартный вывод одной команды можно связать со стандартным вводом другой.

команда1 | команда2

ls -l /usr/bin | less


== Filters ==

Конвейеры часто используются для выполнения сложных операций с данными. Они позволяют объединить вместе несколько команд. Часто команды, используемые таким способом, называют фильтрами. Фильтры принимают ввод, изменяют его определённым образом и выводят результат.

=== sort ===
Фильтр sort сортирует вывод по алфавиту
ls /bin /usr/bin | sort | less

=== uniq ===
Фильтр uniq - поиск и удаление повторяющихся строк
ls /bin /usr/bin | sort | uniq | less

=== wc ===
Фильтр wc - (word count) используется для подсчета числа строк, слов и байтов в файлах.
wc ls-output.txt
ls /bin /usr/bin | sort | uniq | wc -l 
(ключ -l выводит только число строк)

=== grep ===
grep поиск строк, соответствующих шаблону.
Часто используется для поиска в файлах текста по шаблону:
grep шаблон [файл ...]
ls /bin /usr/bin | sort | uniq | grep zip
Параметры:
-i игнор регистра при поиске
-v выводить строки, где совпадение не найдено

=== head/tail ===
head/tail выводят первые/последние 10 строк файла
С помощью ключа -n можно изменить кол-во выводимых строк
head -n 5 ls-output.txt
ls /usr/bin | tail -n 5
tail -f /var/log/messages
ключ -f позволяет следить за файлом и при добавлении в конец этого файла новых строк немедленно выводит их до тех пор пока не нажать <C-C>

=== tee ===
tee читает данные со stdin и копирует их в stdout (чтобы дать возможность передать их дальше по конвейеру) и в один или несколько файлов. Это может пригодиться для сохранения промежуточных результатов обработки в конвейере.
ls /usr/bin | tee ls.txt | grep zip


== Commands ==

=== ls ===
ls - список содержимого файла.

        Аргументы

-a  |  --all   Список всех файлов, даже с именами, начинающимися с точки.   

-d  |  --direcotory   Обычно в присутствии этого параметра команда выводит информацию о самом каталоге, а не его содержимое. Используйте этот параметр в сочетании с параметром -l, чтобы получить дополнительную информацию о каталоге, а не о его содержимом 

-F  |  --classify   Добавляет в конец каждого имени символ-индикатор (например, прямой слеш, если это имя каталога)

-h  |  --human-readable   При использовании длинного формата вывода отображает размеры файлов не в байтах, а в величинах с единицами измерения

-l   Выводит результаты с использованием длинного формата

-r  |  --reverse   Выводит результаты в обратном порядке. Обычно команда ls выводит результаты в алфавитном порядке

-S   Сортировать результаты по размеру (size)

-t   Сортировать результаты по времени (time) последнего изменения 


=== cp ===
cp  копирует файлы и каталоги

cp item1 item2
cp элемент... каталог

Аргументы cp:
-a, --archive       Скопировать файлы и каталоги со всеми 
                    атрибутами, включая идентификаторы 
                    владельцев и права доступа.
                    Без этого параметра копии обычно 
                    получают значения атрибутов по 
                    умолчанию, определённых для
                    пользователя, выполняющего копирование
-i, --interactive   Запрашивать у пользователя 
                    подтверджение перед перезаписью 
                    существующего файла.
-r, --recursive     Рекурсивно копировать каталоги и их 
                    содержимое. Это обязательный параметр 
                    (или параметр -а) при
                    копировании каталогов
-u, --update        При копировании файлов из одного 
                    каталога в другой копировать только 
                    файлы, отсутствующие в каталоге
                    назначения или более новые
-v, --verbose       Выводить информационные сообщения в 
                    процессе копирования

cp file1 file2      (если file2 сущ., он будет затерт)
cp -i file1 file2   (то же, но если file2 сущ., будет запрошено подтверждение перед перезаписью файла)
cp file1 file2 dir1 (каталог dir1 должен существовать)
cp dir1/* dir2      (каталог dir2 должен существовать)
cp -r dir1 dir2     (если dir2 не сущ., он будет создан)


=== mv ===

mv  перемещает/переименовывает файлы и каталоги

mv item1 item2          перемещает или переименовывает файл или каталог item1 в item2
mv элемент... каталог   перемещает один или более элементов из одного каталога в другой

Параметры mv
-i, --interactive   то же, что и cp
-u, --update        перемещает только отсутствующие или более новые файлы в каталоге назначения
-v, --verbose       выводит информационные сообщения в процессе перемещения


mv file1 file2      переместит file1 в file2. Если file2 
                    существует, он будет заменен на новый 
                    файл file1. Если file2 отсутствует, 
                    он будет создан. В любом случае 
                    появится новый файл file2

mv -i file1 file2   то же, но если file2 существует, 
                    будет запрошено подтверждение перед 
                    перезаписью

mv file1 file2 dir1 каталог dir1 должен существовать

mv dir1 dir2        если каталог dir2 не существует, он 
                    будет создан и заполнен содержимым 
                    каталога dir1. Каталог dir1 будет 
                    удалён

=== file ===

file - определяет тип файла.
file имя_файла  выводит краткое описание содержимого файла


=== rsync ===

sudo pacman -S rsync

---------------------------

$ rsync [параметры] {source} {destination}

$ rsync -av dir1 dir2   копирует dir1 в dir2  
$ rsync -av dir1/ dir2  копирует содержимое dir1 в dir2  
                        ключи:
                        -a  копировать атрибуты
                        -v  подробный вывод
                        
=== ssh  ===

sudo pacman -S openssh

--------------------------
Проверить состояние:
sudo systemctl status sshd

Включить sshd (запускается при загрузке системы):
sudo systemctl enable sshd

Выключить sshd:
sudo systemctl disable sshd

Запустить sshd (достаточно этой команды)
sudo systemctl start sshd
--------------------------


  Подключение по SSH
  ------------------

Папка
~/.ssh

Сгенерировать ключи
ssh-keygen

~/.ssh/id_rsa (Приватные ключи)
~/.ssh/id_rsa.pub (Публичные ключи)

Скопировать id_rsa.pub

В профиле github.com Settings > SSH and GPG keys > New SSH key
В поле title название ключа (напр. Linux SSH key)
В поле key вставить скопированный ранее ключ

При клонировании проектов нужно использовать ssh ссылку

Посмотреть ссылку подключения
git remote -v
Если в проекте уже установлена обычная https ссылка, то
изменить на ssh
git remote set-url origin {ssh_link}


=== mkdir ===

mkdir   создает каталоги

mkdir каталог...    ... - означает, что аргументов 
                    может быть несколько

mkdir dir1
mkdir dir1 dir2 dir3

Пример создания группы каталогов с именами, состоящими из номера года и месяца в хронологическом порядке:
$ mkdir Pictures
$ cd Pictures
$ mkdir {2009..2011}-0{1..9} {2009..2011}-{10..12}
$ mkdir -p {2009..2011}/{01..12}    ключ -p нужен для создания родительского
                                    каталога


=== rm ===

rm      удаляет файлы и каталоги

rm элемент...

Параметры:
-i, --interactive   то же, что и выше
-r, --recursive     рекурсивно удалять каталоги. Это обязательный параметр при удалении каталогов
-f, --force         Игнорировать отсутствующие файлы и не запрашивать подтверждения. Этот параметр отменяет действие 
                    параметра --interactive
-v, --verbose       выводить информационные сообщения в процессе удаления

rm file1
rm -i file1
rm -r file1 dir1
rm -rf file1 dir1   в отсутствие file1 и/или dir1 продолжит работу, не выводя никаких сообщений


=== ln ===
ln      создает жесткие и символические ссылки

ln файл ссылка          создаёт жёсткую ссылку
ln -s элемент ссылка    создает символическую ссылку, где элементом может быть файл или каталог.


=== man ===
man программа   справоч. рук-во по программе
man раздел искомый термин

Разделы man:
1   -   пользовательские команды 
2   -   программные интерфейсы системных вызовов в ядре 
3   -   программные интерфейсы в библиотеке С 
4   -   специальные файлы, такие как узлы устройств и 
        драйверы 
5   -   форматы файлов 
6   -   игры и развлечения, такие как хранители экрана 
7   -   прочее
8   -   команды системного администрирования 

команда man с параметром -k действует как apropos


=== whatis ===
whatis  выводит имя и однострочное описание из страницы справочного рук-ва

whatis ls


=== info ===
info программа

Команды программы info:
?                   Вывести справку 
PgUp или Backspace  Вывести предыдущую страницу 
PgDown или Пробел   Вывести следующую страницу 
n                   Вперед (next) - вывести следующий узел 
p                   Назад (previous) - вывести предыдущий узел 
u                   Вверх (up) - вывести узел,
                    родительский по отношению к текущему, 
                    обычно меню 
ENTER               Перейти по гиперссылке, находящейся на позиции курсора 
u                   Завершить (quit) 

Большинство программ является частью пакета coreutils проекта GNU, поэтому о них можно получить дополнительную информацию командой
info coreutils

alias имя='строка'  вокруг равно не должно быть пробелов
unalias имя         удалить псевдоним


=== cat ===
cat [file ...]
В отсутствие аргументов cat копирует содержимое стандартного ввода в стандартный вывод. Эту её особенность можно использовать для создания коротких текстовых файлов.

cat > eat_more.txt
"Съешь ещё этих мягких французских булок, да выпей чаю." <C-d> (чтобы сообщить команде cat, что достигнут конец файла на стандартном вводе)


=== echo ===
echo выводит свои текстовые аргументы в stdout
echo this is a test
echo *
echo ~
echo $((2 + 2))

echo $((выражение))
Механизм подстановки арифметических выражений позволяет использовать только целые числа (невещественные), зато поддерживает множество арифметических операций.

Операторы:

+   Сложение
-   Вычитание
*   Умножение
/   Деление (результат будет целое число из-за того, что
    подстановка поддерживает только целочисленную арифм.)
%   Деление по модулю или остаток от деления
**  Возведение в степень  

echo $(($((5**2)) * 3))

Для группировки подвыражений допускается использование одиночных круглых скобок.

echo $(((5**2) * 3))

    Подстановка фигурных скобок
    ---------------------------

$ echo Впереди-{A,B,C}-позади
Впереди-А-позади Впереди-В-позади Впереди-С-позади

$ echo Число {1..5}

$ echo {Z..A}

$ echo a{A{1,2},B{3,4}}b


    Подстановка параметров
    ----------------------

echo $USER

Чтобы увидеть список доступных переменных:
printenv | less


    Подстановка команд
    ------------------

Подстановка команд позволяет использовать поток вывода команд в качестве аргументов других команд:
echo $(ls)

ls -l $(which cp)   Здесь результат команды which cp передается как аргумент команде ls, благодаря чему мы получаем информацию о программе cp, не зная полного пути к ней.

Можно использовать конвееры:
file $(ls /usr/bin/* | grep zip)

Альтернативный синтаксис, унаследованный от более старых командных оболочек. Вместо знака доллара и круглых скобок используются обратные апострофы:

ls -l `which cp`


    Экранирование
    -------------

1. Двойные кавычки
Если заключить текст в двойные кавычки, все спецсимволы потеряют своё значение и будут интерпретироваться как обычные симовлы. Исключение сост.: $, \ и `. То есть разбиение на слова, подстановка путей, подстановка тильды и подстановка фигурных скобок выполняться не будут, но подстановка параметров, подстановка значений арифметических выражений и подстановка команд всё ещё будут выполняться.

2. Одиночные кавычки
Подавляют все подстановки

3. Экранирование символов
Обратный слеш \ используется для экранирования одного симовла.
Чтобы включить сам экранирующий символ, его также нужно экранировать \\.

    Управляющие последовательности

\a      Подать звуковой сигнал
\b      Забой (bakspace)
\n      Новая строка
\r      Возврат каретки
\t      Табуляция

Параметр -e команды echo включает интерпретацию управляющих последовательностей. Их можно также заключать в конструкцию $' '.

Пример использования команды sleep:
    sleep 10; echo -e "Time's up\a"

То же самое можно выразить так:
    sleep 10; echo "Time's up" $'\a'
