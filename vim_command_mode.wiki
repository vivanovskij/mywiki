[[index|Main]]
[[vim|Back]]


       == Режим командной строки ==
        
:[range]delete[x]               Удалит указанные строки 
:[range]d[x]                    [в регистр х]

:[range]yank[x]                 Скопирует указанные 
                                строки [в регистр х]
:[line]put[x]                   Вставит текст из  
                                регистра х после 
                                указанной строки
:[range]copy{addr}, :t          Скопирует строки ниже 
                                строки с номером {addr}
:[range]move{addr}, :m          То же переместит
:[range]join                    Объединит строки
:[range]normal{commands}        Выполнит команду         
                                {commands} командного
                                режима для каждой строки
:[range]substitute/{pattern}/   Заменит вхождения
/{string}/[flags]               {pattern}
                                последовательностью
                                символов {string}
                                в каждой строке
:[range]global/{pattern}/[cmd]  Выполнит команду [cmd]
                                для всех строк из числа
                                указанных, где найдено
                                вхождение {pattern}
@:                              повторить послед. команду
:h ex-cmd-index                 справка по командам
:bn[ext]                        обход списка буферов впер.
:bp[revious]                    то же назад
<C-d>,<Tab>|<S-Tab>             автодополнение команд
<C-r><C-w>                      скопировать слово,
                                находящееся под курсором
:<Up>|<Down>                    История команд
q/                              Открыть окно режима 
                                командной строки с 
                                историей поиска
q:                              То же с историей команд
C-f                             Перейти из командной 
                                строки в окно режима 
                                командной строки

@: имеет сходство с выполнением макроса. Нужно отметить, что регистр : всегда хранит самую последнюю команду режима командной строки.

        == Диапазон [range] ==

:{start},{end}  (:10,20print)

В качестве адреса можно использовать:
.   текущая строка
$   последняя строка в файле
0   виртуальная строка в файле, выше первой строки
1   первая строка в файле
'm  строка с меткой m
'<  начало визуального выделения
'>  конец визуального выделения
%   все строки в текущем файле (то же что и :1,$)

В качестве адресов строк можно использовать шаблоны
:/{start}/,/{end}/ напр.: (:/<html>/,/<\/html>/p)
:{address}+n    определяет смещение 
                напр.: (:/<html>/+1,/<\/html>-1/)

:2          перейдет на 2-ю строку
:.,$p       выведет на экран(p) со 2-й до последней стр.


        == Запуск программ в командной оболочке ==

:!{cmd}     запуск внешних команд

:!ls
:!python3 %     знак % - сокращ. форма имени текущ. файла
:h filename-modifiers   справка по модификаторам (типа %)
:shell      запуск интерактивной оболочки

<C-z> приостанавливает процесс, в котором выполняется vim, и передаст управление оболочке bash. Процесс Vim будет простаивать в фоновом режиме, позволяя нам взаимодействовать с командной оболочкой. Получить список заданий можно с помощью $ jobs. Возобновить приостановленное задание в оболочке можно командой fg.


    == Передача содержимого буфера на вход командам  ==
        == и сохранение вывода команд в буфере ==

:read !{cmd}    сохранение вывода команды в текущем буфере
:write !{cmd}   передает содержимое буфера в stdin

Восклицательный знак может придавать командам разный смысл в зависимости от местоположения.
:write !sh  передает содержимое буфера на stdin команде sh
            в командной оболочк будет выполнена каждая 
            строка из текущего буфера
:write ! sh то же 
:write! sh  команда перезаписи файла sh

== Фильтрация содержимого буфера с помощью внешней команды ==

Команда :!{cmd} приобретает иной смысл, когда ей передается диапазон строк. Строки, определяемые диапазном [range], передаются на стандартный ввод команды {cmd}, а ее вывод затирает оригинальное содержимое диапазона.
:h :range!
:[range]!{filter}
:{motion}   переведёт редактор в режим командной строки и подставит в поле [range] диапазон, соответствующий указанному аргументу {motion}. Например, если поместить курсор в стр.2 и выполнить !G, Vim откроет командную строку и подставит в неё диапазон :.,$!

:shell          Запускает командную оболочку (возврат в 
                Vim выполняется командой exit)
:!{cmd}         Выполняет команду {cmd} в командной 
                оболочке
:read !{cmd}    Выполняет команду {cmd} в командной 
                оболочке и ставляет вывод ниже курсора
:[range]write !{cmd} Выполняет команду {cmd} в командной 
                        оболочке и передает на её 
                        стандартный ввод указанный 
                        диапазон строк [range]
:[range]!{filter}   Фильтрует указанный диапазон строк 
                    [range] с помощью внешней команды 
                    {filter}

Некоторые команды интерпретируются редактором Vim особо. Например, для команд make и grep имеются отдельные команды-обёртки.


    == Выполнение сразу нескольких команд Ex ==

:source {script}    запустить сценарий
:source batch.vim

:argdo source {scripts} запустить сценарий сразу для 
                        нескольких файлов (открытых в 
                        буферах)

    == Управление несколькими файлами ==

:ls     Список буферов % - текущий файл # - альтернативный
:bnext  следующий буфер
:bprev  предыдущий буфер
:bfirst в начало списка
:blast  в конец списка
:buffer N   перейти к буферу непосредственно
:buffer {bufname}   в имени {bufname} можно указать лишь 
                    первые символы имени идентифицирующие 
                    буфер
:bufdo  применить команду Ex ко всем буферам, 
        пречисляемым командой ls
<C-^>   переключиться на следующий файл
:bd[elete]              удаление буфера
:bd[elete] N1 N2 ...    удаление нескольких буферов
:N,M bd[elete]          удаление от N до M буферов


    == Назначение горячих клавиш для обхода списков в Vim: ==
    
Из расширения unimpaired.vim (https://github.com/tpope/vim-unimpaired)
nnoremap <silent> [b :bprevious<CR>
nnoremap <silent> ]b :bnext<CR>
nnoremap <silent> [B :bfirst<CR>
nnoremap <silent> ]B :blast<CR>

    == Группировка буферов с помощью списка агрументов ==

:args       список файлов, перечисленных при выполнении 
            команды vim (при открытии :h args_f)
:args {argslist}    аргумент {arglist} может включать 
                    имена файлов, групповые симовлы и 
                    даже вывод команды оболочки
Пример:
:args index.html app.js

Для определения шаблонов имён файлов и каталогов можно использовать групповые симовлы. 
Символ * соответствует нулю или более символам, но только в пределах указанного каталога (:h wildcard). 
Символ ** также соответствует нулю или более символам, но он позволяет углубляться во вложенные подкаталоги (:h starstar-wildcard)
Допускается объединять эти групповые символы с фрагментами имён файлов и каталогов для составления шаблонов, соответствующих множеству файлов, представляющих интерес:
:args *.*
:args **/*.*
:args **/*.js
Так же как в {arglist} можно указать несколько имён файлов, можно указать и несколько шаблонов:
:args **/*.js **/*.css

    == Определение файлов с помощью обратных кавычек ==
    
Можно создать текстовый файл (напр. .chapters) с именами файлов под одному в каждой строке:

the_vim_way.txt
normal_mode.txt
insert_mode.txt
visual_mode.txt

Заполнить список агрументов из этого файла можно следующей командой:

:args `cat .chapters`

Текст, находящийся в обратных кавычках, Vim выполнить в командной оболочке, а вывод передаст как аргумент команде :args

Список аргументов более прост в управлении, чем список буферов, что делает его идеальным средством группировки буферов в коллекции. Единственной командой :args {arglist} можно очистить и тут же заполнить список аргументов новыми элементами. Команды :next, :prev обеспечивают возможность навигации. Команда :argdo позволяет применить одну и ту же команду к каждому буферу в коллекции.


    == Управление скрытыми файлами ==

:e[dit]!    эта команда прочитает файл с диска и затрёт 
            содержимое буфера
:qa[ll]!    закрыть Vim невзирая на наличие изменений в 
            буферах
:wa[ll]     сохранить все буферы сразу

        == Команда :argdo ==

Команда :argdo {cmd} действует примерно след. образом:
:first
:{cmd}
:next
:{cmd}
и т.д.

    Если выбранная команда {cmd} изменит содержимое первого буфера, следующая за ней команда :next потерпит неудачу. Vim не позволит перейти ко второму пункту в списке аргументов, пока не будут сохранены изменения в первом. Чтобы использовать команды :next, :bnext, :cnext (и др.) без завершающего восклицательного знака нужно включить параметр hidden (:h 'hidden'). Параметр настройки hidden позволяет использовать команды :argdo и :bufdo для изменения буферов в коллекции единственной командой.
    После выполнения команды :argdo {cmd} может потребоваться сохранить изменения, внесенные в каждый элемент списка аргументов. Мы могли бы сохранить буферы по одному, выполнив :first и затем :wn, получив попутную возможность просмотреть каждый файл. Или, если нет никаких сомнений, что всё в порядке, можно выполнить команду :argdo write (или :wall), чтобы сохранить сразу все буферы.

